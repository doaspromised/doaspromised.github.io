<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态数组及优化</title>
      <link href="/2020/03/02/expandarray/"/>
      <url>/2020/03/02/expandarray/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift-动态数组及优化"><a href="#Swift-动态数组及优化" class="headerlink" title="Swift-动态数组及优化"></a>Swift-动态数组及优化</h1><p>前言：数组是一种顺序存储的线性表，所有的元素的内存地址是连续。在很多编程语言中，数组都有个致命的缺点，<strong>无法动态修改容量</strong>, 在实际开发中，我们更希望数组的容量是可以动态改变的。所以，使用Swift实现一个动态扩容数组, Swift本身数组就是动态扩容的, 为什么选择Swift呢？其实用Java, OC等语言都可以实现动态数组，选择Swift只是为了熟练下Swift语法, 思路其实是更重要的。更多的细节，看<a href="https://github.com/doaspromised/Swift-algorithm" target="_blank" rel="noopener">这里</a></p><h3 id="1、动态数组的接口设计"><a href="#1、动态数组的接口设计" class="headerlink" title="1、动态数组的接口设计"></a>1、动态数组的接口设计</h3><pre><code>     /// 数组长度    var count: Int { get }    /// 是否为空    var isEmpty: Bool { get }    /// 是否包含元素    func contains(_ element: T) -&gt; Bool {}    /// 清除所有元素    func clear() {}    /// 获取或者更改 inde 位置的元素    mutating func set(at index: Int, newElement: T) -&gt; T {}    func getElement(at index: Int) -&gt; T {}    subscript(index: Int) -&gt; T { set get }    /// 指定位置添加元素    func add(at index: Int, newElement: T) {}    /// 删除指定位置的元素    func remove(at index: Int) -&gt; T {}</code></pre><h3 id="2、动态数组的设计"><a href="#2、动态数组的设计" class="headerlink" title="2、动态数组的设计"></a>2、动态数组的设计</h3><p><img src="https://img.rruu.net/image/5e5d163d7459b" alt=""></p><p>本篇文章主要想写一下关于数组的扩容，以及如何优化增删操作。</p><h4 id="（1）两个主要私有属性：size-和-elements"><a href="#（1）两个主要私有属性：size-和-elements" class="headerlink" title="（1）两个主要私有属性：size 和 elements"></a>（1）两个主要私有属性：size 和 elements</h4><ul><li>size： 记录当前数组长度</li><li>elements： 元素容器</li></ul><h4 id="（2）添加元素"><a href="#（2）添加元素" class="headerlink" title="（2）添加元素"></a>（2）添加元素</h4><ul><li>最好的情况：在数组尾部添加，无需移动元素，复杂度为 O(1), </li><li>最坏情况：在头部添加元素，需要把所有元素往后移动一位，复杂度为 O(n)</li><li>元素移动如下图所示</li></ul><p><img src="https://img.rruu.net/image/5e5d1aacdec17" alt=""></p><h4 id="（3）移除元素"><a href="#（3）移除元素" class="headerlink" title="（3）移除元素"></a>（3）移除元素</h4><ul><li>最好的情况：删除尾部元素，无需移动元素，复杂度为O (1)</li><li>最差的情况：删除头部元素, 需要把所有元素往前移动一位，复杂度为 O(n)</li><li>元素移动如下图所示<br><img src="https://img.rruu.net/image/5e5d26745833a" alt=""></li></ul><h3 id="3、优化数组增删的复杂度"><a href="#3、优化数组增删的复杂度" class="headerlink" title="3、优化数组增删的复杂度"></a>3、优化数组增删的复杂度</h3><p>数组在头部增删时，需要把所有元素都移动, 我们尝试把复杂度降到 O(1)。主要思路是: <strong>元素不动，头部开始位置动</strong>。 添加一个start标记，start就是动态数组真正的第一个元素，每次取数据，通过 start 和 index，计算出真正的索引位置，然后 get / set 元素等操作</p><h4 id="（1）增加一个属性-start-用来标记当前头部元素的位置"><a href="#（1）增加一个属性-start-用来标记当前头部元素的位置" class="headerlink" title="（1）增加一个属性 start, 用来标记当前头部元素的位置"></a>（1）增加一个属性 start, 用来标记当前头部元素的位置</h4><pre><code>// 当前开始位置指向的索引值, 默认为0private var start = 0</code></pre><h4 id="（2）修改添加元素代码（删除逻辑相同，反操作）"><a href="#（2）修改添加元素代码（删除逻辑相同，反操作）" class="headerlink" title="（2）修改添加元素代码（删除逻辑相同，反操作）"></a>（2）修改添加元素代码（删除逻辑相同，反操作）</h4><pre><code>    /// 指定位置添加元素    /// - Parameters:    ///   - index: 位置    ///   - newElement: 元素    mutating func add(at index: Int, newElement: T) {        ensureCapacity(capacity: size + 1)        if index == size { // 尾部插入            elements[realIndex(size + 1)] = newElement        } else if index == 0 { // 头部插入            start =  start &gt; 0 ? (start - 1) :  (capacity - 1)            elements[start] = newElement        } else { // 中间插入            let middleIdx = size &gt;&gt; 1            // 尽量移动少量的元素。如果插入左半部分，将左半部分元素左移，反之亦然            if index &gt; middleIdx {                for idx in (index..&lt;size).reversed() {                    elements[idx+1] = elements[idx]                }            } else {                start = start - 1 &lt; 0 ? (capacity - 1) : (start - 1)                for idx in (0..&lt;index) {                    let realIdx = realIndex(idx)                    elements[realIdx] = elements[idx]                }            }            elements[realIndex(index)] = newElement        }        size++    }    /// 获取真正的索引    /// - Parameter index    private func realIndex(_ index: Int) -&gt; Int {        let realIdx = start + index        return (realIdx &gt;= capacity) ? (realIdx % capacity) : realIdx    }</code></pre><h5 id="分三种情况：-头部插入-尾部插入，和中间插入"><a href="#分三种情况：-头部插入-尾部插入，和中间插入" class="headerlink" title="分三种情况： 头部插入, 尾部插入，和中间插入"></a>分三种情况： 头部插入, 尾部插入，和中间插入</h5><ul><li>头部插入: 每次在头部插入，只需将start位置左移，然后把新的元素插入进来，剩余元素无需移动。<ul><li>如果start &gt; 0，每次头部插入，start 左移，新元素插入进来。</li><li>如果start为0，需要将start 左移一位，0左移就是 (capacity - 1)</li><li>依次执行，形成闭环。</li></ul></li><li>尾部插入：由于start不一定是0， 所以 size + 1不一定是要插入的真正位置，通过 realIndex 函数计算出真正的尾部位置，插入</li><li>中间插入：这种情况下，仅仅通过改动 start 位置是无法实现的，只能尽可能少量的移动元素。根据midlleIdx，判断是插入左半部分还是右半部分<ul><li>右半部分：右移插入。把要插入索引位置的元素到最后一个元素都往右移动一个位置即可</li><li>左半部分：左移插入。把要插入索引位置的前一个元素到第0个元素，都左移一位。左移，就会改动start，此时计算新的start 位置。</li></ul></li></ul><h3 id="4、如何扩容"><a href="#4、如何扩容" class="headerlink" title="4、如何扩容"></a>4、如何扩容</h3><p><img src="https://img.rruu.net/image/5e5d268f20bde" alt=""><br>当添加元素的时候，数组容量已满，此时需要扩容。把当前 elements 容器中的所有元素拷贝到容量更大的新容器, 把新容器作为数组的容器。</p><pre><code>    /// 动态扩容    /// - Parameter capacity:    private mutating func ensureCapacity(capacity: Int) {        let oldCapacity = elements.count        if capacity &gt; oldCapacity {            let oldElements = elements            // 新容量为旧容量的1.5倍            let newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)            elements = [T](repeating: defaultValue, count: newCapacity)            // 使用内存拷贝            // memcpy(&amp;elements, &amp;oldElements, elements.count * MemoryLayout&lt;T&gt;.stride)            for (idx, _) in oldElements.enumerated() {                elements[idx] = oldElements[realIndex(idx)]            }            start = 0            self.capacity = newCapacity        }    }</code></pre><h3 id="5、结尾语"><a href="#5、结尾语" class="headerlink" title="5、结尾语"></a>5、结尾语</h3><p>数组是我们经常使用一种数据结构，iOS 开发中，无论OC 中的 NSMutableArray 还是Swift中的 Array，都可以动态扩容，而且苹果对做了很多的优化。自己用Swift简单实现一个动态扩容数组，并优化元素的移动，这个过程也是很有收获的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Swift-algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift-algorithm </tag>
            
            <tag> 动态数组 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里、字节：一套高效的iOS面试题</title>
      <link href="/2020/03/01/a-li-zi-jie-yi-tao-gao-xiao-de-ios-mian-shi-ti/"/>
      <url>/2020/03/01/a-li-zi-jie-yi-tao-gao-xiao-de-ios-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里、字节：一套高效的iOS面试题"><a href="#阿里、字节：一套高效的iOS面试题" class="headerlink" title="阿里、字节：一套高效的iOS面试题"></a>阿里、字节：一套高效的iOS面试题</h1><p>这是在<a href="https://mp.weixin.qq.com/s/bDnsaD__ZpdHIk3_So382w" target="_blank" rel="noopener">知识小集</a>看到的一套面试题，其中大部分都是大厂面试或者面试其他人用到的，能命中大部分的面试和日常工作，更希望你可以用它来检验自己</p><h2 id="runtime相关问题"><a href="#runtime相关问题" class="headerlink" title="runtime相关问题"></a>runtime相关问题</h2><p>runtime是iOS开发最核心的知识了，如果下面的问题都解决了，那么对runtime的理解已经很深了。<br>runtime已经开源了，这有一份别人调试好可运行的源码objc-runtime，也可以去官网找objc4</p><p><a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="noopener">objc-runtime地址</a></p><p><a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4地址</a></p><h3 id="结构模型"><a href="#结构模型" class="headerlink" title="结构模型"></a>结构模型</h3><ul><li>介绍下runtime的内存模型（isa、对象、类、metaclass、结构体的存储信息等）</li><li>为什么要设计metaclass</li><li>class_copyIvarList &amp; class_copyPropertyList区别</li><li>class_rw_t 和 class_ro_t 的区别</li><li>category如何被加载的,两个category的load方法的加载顺序，两个category的同名方法的加载顺序</li><li>category &amp; extension区别，能给NSObject添加Extension吗，结果如何<br>消息转发机制，消息转发机制和其他语言的消息机制优劣对比</li><li>在方法调用的时候，方法查询-&gt; 动态解析-&gt; 消息转发 之前做了什么</li><li>IMP、SEL、Method的区别和使用场景</li><li>load、initialize方法的区别什么？在继承关系中他们有什么区别</li><li>说说消息转发机制的优劣</li></ul><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><ul><li>weak的实现原理？SideTable的结构是什么样的</li><li>关联对象的应用？系统如何实现关联对象的</li><li>关联对象的如何进行内存管理的？关联对象如何实现weak属性</li><li>Autoreleasepool的原理？所使用的的数据结构是什么</li><li>ARC的实现原理？ARC下对retain &amp; release做了哪些优化</li><li>ARC下哪些情况会造成内存泄漏</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>Method Swizzle注意事项</li><li>属性修饰符atomic的内部实现是怎么样的?能保证线程安全吗</li><li>iOS 中内省的几个方法有哪些？内部实现原理是什么</li><li>class、objc_getClass、object_getclass 方法有什么区别?</li></ul><h2 id="NSNotification相关"><a href="#NSNotification相关" class="headerlink" title="NSNotification相关"></a>NSNotification相关</h2><p>苹果并没有开源相关代码，但是可以读下GNUStep的源码，基本上实现方式很具有参考性<br><a href="https://github.com/gnustep/libs-base" target="_blank" rel="noopener">GNUStep地址</a></p><ul><li>实现原理（结构设计、通知如何存储的、name&amp;observer&amp;SEL之间的关系等）</li><li>通知的发送时同步的，还是异步的</li><li>NSNotificationCenter接受消息和发送消息是在一个线程里吗？如何异步发送消息</li><li>NSNotificationQueue是异步还是同步发送？在哪个线程响应</li><li>NSNotificationQueue和runloop的关系</li><li>如何保证通知接收的线程在主线程</li><li>页面销毁时不移除通知会崩溃吗</li><li>多次添加同一个通知会是什么结果？多次移除通知呢</li><li>下面的方式能接收到通知吗？为什么<pre><code>// 发送通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotification:) name:@"TestNotification" object:@1];// 接收通知[NSNotificationCenter.defaultCenter postNotificationName:@"TestNotification" object:nil];</code></pre></li></ul><h2 id="Runloop-amp-KVO"><a href="#Runloop-amp-KVO" class="headerlink" title="Runloop &amp; KVO"></a>Runloop &amp; KVO</h2><h3 id="runloop"><a href="#runloop" class="headerlink" title="runloop"></a>runloop</h3><p>runloop对于一个标准的iOS开发来说都不陌生，应该说熟悉runloop是标配，下面就随便列几个典型问题吧</p><ul><li>app如何接收到触摸事件的</li><li>为什么只有主线程的runloop是开启的</li><li>为什么只在主线程刷新UI</li><li>PerformSelector和runloop的关系</li><li>如何使线程保活</li></ul><h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>同runloop一样，这也是标配的知识点了，同样列出几个典型问题</p><ul><li>实现原理</li><li>如何手动关闭kvo</li><li>通过KVC修改属性会触发KVO么</li><li>哪些情况下使用kvo会崩溃，怎么防护崩溃</li><li>kvo的优缺点</li></ul><h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><ul><li>block的内部实现，结构体是什么样的</li><li>block是类吗，有哪些类型</li><li>一个int变量被 __block 修饰与否的区别？block的变量截获</li><li>block在修改NSMutableArray，需不需要添加__block</li><li>怎么进行内存管理的</li><li>block可以用strong修饰吗</li><li>解决循环引用时为什么要用<strong>strong、</strong>weak修饰</li><li>block发生copy时机</li><li>Block访问对象类型的auto变量时，在ARC和MRC下有什么区别</li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>主要以GCD为主</p><ul><li>iOS开发中有多少类型的线程？分别对比</li><li>GCD有哪些队列，默认提供哪些队列</li><li>GCD有哪些方法api</li><li>GCD主线程 &amp; 主队列的关系</li><li>如何实现同步，有多少方式就说多少</li><li>dispatch_once实现原理</li><li>什么情况下会死锁</li><li>有哪些类型的线程锁，分别介绍下作用和使用场景</li><li>NSOperationQueue中的maxConcurrentOperationCount默认值</li><li>NSTimer、CADisplayLink、dispatch_source_t 的优劣</li></ul><h2 id="视图-amp-图像相关"><a href="#视图-amp-图像相关" class="headerlink" title="视图&amp;图像相关"></a>视图&amp;图像相关</h2><ul><li>AutoLayout的原理，性能如何</li><li>UIView &amp; CALayer的区别</li><li>事件响应链</li><li>drawrect &amp; layoutsubviews调用时机</li><li>UI的刷新原理</li><li>隐式动画 &amp; 显示动画区别</li><li>什么是离屏渲染</li><li>imageName &amp;  imageWithContentsOfFile区别</li><li>多个相同的图片，会重复加载吗</li><li>图片是什么时候解码的，如何优化</li><li>图片渲染怎么优化</li><li>如果GPU的刷新率超过了iOS屏幕60Hz刷新率是什么现象，怎么解决</li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>如何做启动优化，如何监控</li><li>如何做卡顿优化，如何监控</li><li>如何做耗电优化，如何监控</li><li>如何做网络优化，如何监控</li></ul><h2 id="开发证书"><a href="#开发证书" class="headerlink" title="开发证书"></a>开发证书</h2><ul><li>苹果使用证书的目的是什么</li><li>AppStore安装app时的认证流程</li><li>开发者怎么在debug模式下把app安装到设备呢</li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="典型源码的学习"><a href="#典型源码的学习" class="headerlink" title="典型源码的学习"></a>典型源码的学习</h3><p>只是列出一些iOS比较核心的开源库，这些库包含了很多高质量的思想，源码学习的时候一定要关注每个框架解决的核心问题是什么，还有它们的优缺点，这样才能算真正理解和吸收</p><ul><li>AFN</li><li>SDWebImage</li><li>JSPatch、Aspects(虽然一个不可用、另一个不维护，但是这两个库都很精炼巧妙，很适合学习)</li><li>Weex/RN, 笔者认为这种前端和客户端紧密联系的库是必须要知道其原理的</li><li>CTMediator、其他router库，这些都是常见的路由库，开发中基本上都会用到</li></ul><h3 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h3><ul><li>手动埋点、自动化埋点、可视化埋点</li><li>MVC、MVP、MVVM设计模式</li><li>常见的设计模式</li><li>单例的弊端</li><li>常见的路由方案，以及优缺点对比</li><li>如果保证项目的稳定性</li><li>设计一个图片缓存框架(LRU)</li><li>如何设计一个git diff</li><li>设计一个线程池？画出你的架构图</li><li>你的app架构是什么，有什么优缺点、为什么这么做、怎么改进</li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ul><li>PerformSelector &amp; NSInvocation优劣对比</li><li>oc怎么实现多继承？怎么面向切面（可以参考Aspects深度解析-iOS面向切面编程）</li><li>哪些bug会导致崩溃，如何防护崩溃</li><li>怎么监控崩溃</li><li>app的启动过程（考察LLVM编译过程、静态链接、动态链接、runtime初始化）</li><li>沙盒目录的每个文件夹划分的作用</li><li>简述下match-o文件结构</li></ul><h2 id="系统基础知识"><a href="#系统基础知识" class="headerlink" title="系统基础知识"></a>系统基础知识</h2><ul><li>进程和线程的区别</li><li>HTTPS的握手过程</li><li>什么是中间人攻击？怎么预防</li><li>TCP的握手过程？为什么进行三次握手，四次挥手</li><li>堆和栈区的区别？谁的占用内存空间大</li><li>加密算法：对称加密算法和非对称加密算法区别</li><li>常见的对称加密和非对称加密算法有哪些</li><li>MD5、Sha1、Sha256区别</li><li>charles抓包过程？不使用charles，4G网络如何抓包</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p>对于移动开发者来说，一般不会遇到非常难的算法，大多以数据结构为主，笔者列出一些必会的算法，当然有时间了可以去LeetCode上刷刷题</p><p>LeetCode地址：<a href="https://leetcode.com/" target="_blank" rel="noopener">https://leetcode.com/</a></p><ul><li>八大排序算法</li><li>栈&amp;队列</li><li>字符串处理</li><li>链表</li><li>二叉树相关操作</li><li>深搜广搜</li><li>基本的动态规划题、贪心算法、二分查找</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC本质- Category</title>
      <link href="/2020/03/01/oc-ben-zhi-category/"/>
      <url>/2020/03/01/oc-ben-zhi-category/</url>
      
        <content type="html"><![CDATA[<h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1><h3 id="1、-分类的使用场合"><a href="#1、-分类的使用场合" class="headerlink" title="1、 分类的使用场合"></a>1、 分类的使用场合</h3><ul><li>模块化类</li></ul><h3 id="2、分类的实现原理"><a href="#2、分类的实现原理" class="headerlink" title="2、分类的实现原理"></a>2、分类的实现原理</h3><ul><li>分类编译之后的底层结构是 struct categoty_t, 里面存储着分类的对象方法，类方法，属性，协议信息</li><li>在程序运行的时候，runtime会将category的数据，合并到类的信息中（类对象、元类对象）</li></ul><h3 id="3、分类和类扩展的区别"><a href="#3、分类和类扩展的区别" class="headerlink" title="3、分类和类扩展的区别"></a>3、分类和类扩展的区别</h3><ul><li>Class Extension 在编译的时候，它的数据就已经包含在类信息中</li><li>Category 是在运行时，才会将数据合并到类信息中。</li></ul><p>other flags<br>-Objc 编译器参数  链接的时候把静态库的分类合并到类信息中去。</p><p>remethodizeClass {<br>    // cls 类对象  cats 分类<br>    attchCategories(cls, cats, cache);</p><p>}</p><p>attchCategories {<br>1、 组合所有分类方法<br>2、重新分配内存（扩容）<br>3.、memoremove： 内存挪动<br>4、memcopy： 内存拷贝<br>}</p><p>后参与编译的分类，在方法列表的最前面</p><p>类扩展里面的东西编译的时候就合并到类里面去了，帮助我们私有化类扩展里面的东西<br>分类是在运行时</p><h3 id="4、load方法"><a href="#4、load方法" class="headerlink" title="4、load方法"></a>4、load方法</h3><ul><li><p>分类也有+ load方法</p></li><li><p><strong>load方法是通过函数指针，找到 load 方法 直接调用的，不是通过 objc_msgSend, 所以， 就跟顺序没有关系了</strong></p></li><li><p>+load 方法会在runtime加载<strong>类</strong>、<strong>分类</strong>时调用，而且只调用一次</p></li><li><p>不管用不用类或者分类，都会先执行 load 方法，把类载进内存</p></li><li><p>load 方法是直接被找到进行调用 不存在分类load方法会覆盖类的load方法。</p></li><li><p>普通方法之所以优先调用分类的方法，是因为走的是消息转发机制， objc_msgSend</p></li><li><p>load方法的调用顺序：</p><ul><li>1、先调用<strong>类</strong>的 + load 方法<ul><li>先调用父类的load的方法，在调用子类的 load 方法</li><li>先编译的类，先加载 load 方法</li></ul></li><li>2、再调用子类的 + load 方法<ul><li>先编译的<strong>子类</strong>，先加载 load 方法</li></ul></li></ul></li><li><p><strong>面试题： Category中有 load 方法吗？load 方法是什么时候调用？ load 方法能继承吗？</strong></p><ul><li>有</li><li>load 方法在runtime 加载类、分类的时候调用</li><li>可以继承，但是一般情况下不会主动去调用load方法，都是系统自动去调用</li></ul></li></ul><h3 id="5、initialize-方法"><a href="#5、initialize-方法" class="headerlink" title="5、initialize 方法"></a>5、initialize 方法</h3><ul><li><p>initialize 方法在类第一次接收到<strong>消息</strong>时调用</p></li><li><p><strong>initialize 方法的调用是通过消息机制，objc_msgSend 调用的</strong></p></li><li><p>调用顺序：</p><ul><li>在调用子类的initialize 之前，先调用父类的 initialize, 如果父类的 initialize 之前已经调用过了， 就不再调用了。</li><li>如果子类没有实现initialiaze方法，则会调用父类的initialize（<strong>所以 父类的initialize 可能会被调用多次</strong>）</li></ul><p>objc_msgSend 底层是通过汇编实现，不是C语言，就是半开源了</p></li></ul><h3 id="6、load-和-initialize-对比"><a href="#6、load-和-initialize-对比" class="headerlink" title="6、load 和 initialize 对比"></a>6、load 和 initialize 对比</h3><h4 id="（1）-load、initialize-方法的区别是什么？"><a href="#（1）-load、initialize-方法的区别是什么？" class="headerlink" title="（1） load、initialize 方法的区别是什么？"></a>（1） load、initialize 方法的区别是什么？</h4><ul><li>调用方式<ul><li>load 方法是通过函数指针直接找到方法地址进行调用</li><li>initialize 是通过消息机制，进行调用</li></ul></li><li>调用时刻<ul><li>load 方法在程序运行时，runtime 加载类、分类的时候，调用</li><li>initialize 方法是在类第一次接收到消息时调用</li></ul></li><li>调用顺序<ul><li>load 方法 先调用类load，在调用分类load；先编译的类，先调用；在调用子类的load之前会先调用父类的load</li><li>initialize 方法 会先调用父类的initialize，再调用子类的initialize；如果子类没有实现initialize ， 会调用父类的initialize，所以父类的initialize 可能会被调用多次。</li></ul></li></ul><h3 id="7、成员变量"><a href="#7、成员变量" class="headerlink" title="7、成员变量"></a>7、成员变量</h3><h4 id="（1）添加属性"><a href="#（1）添加属性" class="headerlink" title="（1）添加属性"></a>（1）添加属性</h4><ul><li>类里创建@property 属性，干了三件事，添加一个成员变量，声明set get 方法，实现 set  get 方法</li><li>分类创建@property 属性，只是声明了方法<h4 id="（2）解决分类保存属性值的方案"><a href="#（2）解决分类保存属性值的方案" class="headerlink" title="（2）解决分类保存属性值的方案"></a>（2）解决分类保存属性值的方案</h4></li><li>创建一个全局变量，在set 方法 和 get 方法的实现中利用 全局变量存取值<ul><li>问题：如果有多个对象，不能保证每个对象都有自己的这个属性。</li></ul></li><li>全局变量使用字典，完善属性<ul><li>问题：线程安全问题，因为每一个对象都可以访问这个全局变量，如果有不同线程的对象同时访问这个全局变量，确实会存在线程安全的问题。</li><li>每次新添加一个属性，都要创建一个全局变量</li></ul></li><li>关联对象<ul><li>给全局变量添加 static，就意味着该变量只可以在本文件内使用，这样就保证了代码的封装性</li><li>关联队形并不存储在被关联的对象的内存中</li><li>关联对象存储在全局统一的一个AssociationManager中</li><li>设置关联对象为nil，就相当于移除关联对象</li><li>removeAssociatedObjects 就是移除被传入对象的所有关联对象</li></ul></li><li>直接写出的字符串 @”name”，在iOS 中是直接放在常量区的，所以，地址值是不变的。</li><li>_cmd 代表当前方法的 selector</li><li>OC 实际上隐藏了两个隐式参数 给我们使用，一个是self， 一个是 _cmd</li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC本质 </tag>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/01/hello-world/"/>
      <url>/2020/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
