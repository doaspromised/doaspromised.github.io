<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2020/03/01/wo-de-di-yi-pian-bo-ke/"/>
      <url>/2020/03/01/wo-de-di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h1><h3 id="1、-分类的使用场合"><a href="#1、-分类的使用场合" class="headerlink" title="1、 分类的使用场合"></a>1、 分类的使用场合</h3><ul><li>模块化类</li></ul><h3 id="2、分类的实现原理"><a href="#2、分类的实现原理" class="headerlink" title="2、分类的实现原理"></a>2、分类的实现原理</h3><ul><li>分类编译之后的底层结构是 struct categoty_t, 里面存储着分类的对象方法，类方法，属性，协议信息</li><li>在程序运行的时候，runtime会将category的数据，合并到类的信息中（类对象、元类对象）</li></ul><h3 id="3、分类和类扩展的区别"><a href="#3、分类和类扩展的区别" class="headerlink" title="3、分类和类扩展的区别"></a>3、分类和类扩展的区别</h3><ul><li>Class Extension 在编译的时候，它的数据就已经包含在类信息中</li><li>Category 是在运行时，才会将数据合并到类信息中。</li></ul><p>other flags<br>-Objc 编译器参数  链接的时候把静态库的分类合并到类信息中去。</p><p>remethodizeClass {<br>    // cls 类对象  cats 分类<br>    attchCategories(cls, cats, cache);</p><p>}</p><p>attchCategories {<br>1、 组合所有分类方法<br>2、重新分配内存（扩容）<br>3.、memoremove： 内存挪动<br>4、memcopy： 内存拷贝<br>}</p><p>后参与编译的分类，在方法列表的最前面</p><p>类扩展里面的东西编译的时候就合并到类里面去了，帮助我们私有化类扩展里面的东西<br>分类是在运行时</p><h3 id="4、load方法"><a href="#4、load方法" class="headerlink" title="4、load方法"></a>4、load方法</h3><ul><li><p>分类也有+ load方法</p></li><li><p><strong>load方法是通过函数指针，找到 load 方法 直接调用的，不是通过 objc_msgSend, 所以， 就跟顺序没有关系了</strong></p></li><li><p>+load 方法会在runtime加载<strong>类</strong>、<strong>分类</strong>时调用，而且只调用一次</p></li><li><p>不管用不用类或者分类，都会先执行 load 方法，把类载进内存</p></li><li><p>load 方法是直接被找到进行调用 不存在分类load方法会覆盖类的load方法。</p></li><li><p>普通方法之所以优先调用分类的方法，是因为走的是消息转发机制， objc_msgSend</p></li><li><p>load方法的调用顺序：</p><ul><li>1、先调用<strong>类</strong>的 + load 方法<ul><li>先调用父类的load的方法，在调用子类的 load 方法</li><li>先编译的类，先加载 load 方法</li></ul></li><li>2、再调用子类的 + load 方法<ul><li>先编译的<strong>子类</strong>，先加载 load 方法</li></ul></li></ul></li><li><p><strong>面试题： Category中有 load 方法吗？load 方法是什么时候调用？ load 方法能继承吗？</strong></p><ul><li>有</li><li>load 方法在runtime 加载类、分类的时候调用</li><li>可以继承，但是一般情况下不会主动去调用load方法，都是系统自动去调用</li></ul></li></ul><h3 id="5、initialize-方法"><a href="#5、initialize-方法" class="headerlink" title="5、initialize 方法"></a>5、initialize 方法</h3><ul><li><p>initialize 方法在类第一次接收到<strong>消息</strong>时调用</p></li><li><p><strong>initialize 方法的调用是通过消息机制，objc_msgSend 调用的</strong></p></li><li><p>调用顺序：</p><ul><li>在调用子类的initialize 之前，先调用父类的 initialize, 如果父类的 initialize 之前已经调用过了， 就不再调用了。</li><li>如果子类没有实现initialiaze方法，则会调用父类的initialize（<strong>所以 父类的initialize 可能会被调用多次</strong>）</li></ul><p>objc_msgSend 底层是通过汇编实现，不是C语言，就是半开源了</p></li></ul><h3 id="6、load-和-initialize-对比"><a href="#6、load-和-initialize-对比" class="headerlink" title="6、load 和 initialize 对比"></a>6、load 和 initialize 对比</h3><h4 id="（1）-load、initialize-方法的区别是什么？"><a href="#（1）-load、initialize-方法的区别是什么？" class="headerlink" title="（1） load、initialize 方法的区别是什么？"></a>（1） load、initialize 方法的区别是什么？</h4><ul><li>调用方式<ul><li>load 方法是通过函数指针直接找到方法地址进行调用</li><li>initialize 是通过消息机制，进行调用</li></ul></li><li>调用时刻<ul><li>load 方法在程序运行时，runtime 加载类、分类的时候，调用</li><li>initialize 方法是在类第一次接收到消息时调用</li></ul></li><li>调用顺序<ul><li>load 方法 先调用类load，在调用分类load；先编译的类，先调用；在调用子类的load之前会先调用父类的load</li><li>initialize 方法 会先调用父类的initialize，再调用子类的initialize；如果子类没有实现initialize ， 会调用父类的initialize，所以父类的initialize 可能会被调用多次。</li></ul></li></ul><h3 id="7、成员变量"><a href="#7、成员变量" class="headerlink" title="7、成员变量"></a>7、成员变量</h3><h4 id="（1）添加属性"><a href="#（1）添加属性" class="headerlink" title="（1）添加属性"></a>（1）添加属性</h4><ul><li>类里创建@property 属性，干了三件事，添加一个成员变量，声明set get 方法，实现 set  get 方法</li><li>分类创建@property 属性，只是声明了方法<h4 id="（2）解决分类保存属性值的方案"><a href="#（2）解决分类保存属性值的方案" class="headerlink" title="（2）解决分类保存属性值的方案"></a>（2）解决分类保存属性值的方案</h4></li><li>创建一个全局变量，在set 方法 和 get 方法的实现中利用 全局变量存取值<ul><li>问题：如果有多个对象，不能保证每个对象都有自己的这个属性。</li></ul></li><li>全局变量使用字典，完善属性<ul><li>问题：线程安全问题，因为每一个对象都可以访问这个全局变量，如果有不同线程的对象同时访问这个全局变量，确实会存在线程安全的问题。</li><li>每次新添加一个属性，都要创建一个全局变量</li></ul></li><li>关联对象<ul><li>给全局变量添加 static，就意味着该变量只可以在本文件内使用，这样就保证了代码的封装性</li><li>关联队形并不存储在被关联的对象的内存中</li><li>关联对象存储在全局统一的一个AssociationManager中</li><li>设置关联对象为nil，就相当于移除关联对象</li><li>removeAssociatedObjects 就是移除被传入对象的所有关联对象</li></ul></li><li>直接写出的字符串 @”name”，在iOS 中是直接放在常量区的，所以，地址值是不变的。</li><li>_cmd 代表当前方法的 selector</li><li>OC 实际上隐藏了两个隐式参数 给我们使用，一个是self， 一个是 _cmd</li><li></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> OC底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OC分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/01/hello-world/"/>
      <url>/2020/03/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
